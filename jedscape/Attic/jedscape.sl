% jedscape.sl -*- mode: Slang; mode: Fold -*-
%
% $Id: jedscape.sl,v 1.1.1.1 2004/10/28 08:16:23 milde Exp $
% keywords: www, help, hypermedia
%
% Copyright (c) 2003 Paul Boekholt.
% Released under the terms of the GNU GPL (version 2 or later).
%
% Mode for reading html documentation in JED.  The idea is to add some
% markup to anchors, pipe the file through html2text and replace the
% anchors by usermarks.  Needed: html2text or something similar.  We
% recommend html2text because it can convert html to outline format, just
% add this to your .html2textrc:
%
% H1.prefix=*
% H2.prefix=**
% etc.
%
% This only handles relative urls that point to a local file.  For
% browsing the web, a real browser is more useful, so we call
% browse_url() in browse_url.sl for http links.
% 
% Hyperlinks are marked by [[: and :]].  This is the same as a regexp
% character class, so if you're reading documentation about grep, don't
% get confused.
%
% If the document has "previous", "up" etc. links, the info motion keys
% work.  Other keys are probably mostly like in lynx.  The customvar
% jedscape_emulation defines some additional keys to emulate lynx,
% netscape or Emacs.  
% 
%  We try to eval a file called jedscape_hook.sl, there you can redefine
%  anything defined in this file.
require("ishell");
require("view");
if (_featurep("jedscape"))
  use_namespace("jedscape");
else
  implements("jedscape");

% Jed_home.html should have links to all your html documentation, like
% the "dir" node in info.  I don't have a function for adding links to
% this page, but your distro may have a script for this, otherwise use
% lynx to bookmark everything.
custom_variable("Jedscape_Home", dircat (Jed_Home_Directory, "jed_home.html"));
% Bookmark file looks like:
% name\thref\n
% like links' bookmark file
custom_variable("Jedscape_Bookmark_File", dircat (Jed_Home_Directory, "jedscape_bookmarks"));

% HTML filter program. possible values:
% lynx -force-html -dump -nolist -stdin -width %d
% w3m -dump -T text/html -cols %d
% links -dump
% However I wrote this for html2text, the syntax highlighting assumes
% that headings start with * at bol, and we assume that \href{ may be
% wrapped after the href but not after the \
% Links does not have an option to set the output width, so set 
% HORIZONTAL_PAN to -1
custom_variable("Jedscape_Html_Filter", "html2text -nobs -width %d");

% this may be lynx, netscape or w3
custom_variable("Jedscape_Emulation", "w3");

static variable mode="jedscape";

static variable
  version="$Revision: 1.1.1.1 $",
  title,
  this_href_mark, last_href_mark, % check if tags don't overlap
  url_file ="",			       %  the source, luke!
  url_root,			       %  dir of current page
  href_list, href_begin_marks, href_end_marks,   %  hyperlinks
  href_anchor_list,		       %  part between <a> and </a>
  href_i,			       %  counter for hrefs
  anchor_list, anchor_marks, anchor_i,	       %  anchors
  links= struct{ previous, next, up, contents};   %  links in <head>

_autoload("jedscape_index_search", "jedscapemisc",
	  "jedscape_view_bookmarks", "jedscapemisc",
	  "jedscape_add_bookmark", "jedscapemisc", 3);

%{{{ html parsing

define bufsubstr_compress()
{
   strcompress(strtrim(bufsubstr()), " \n");
}

% Some pages smear their tags out across several lines, JED's regexp
% search can't handle that.
static define fix_broken_markup(mark)
{
   bob;
   while (re_fsearch(sprintf("\\C%s$", mark)))
     {
	newline;
	go_right_1;
	eol;
	del;
	trim;
     }
   bob;
}

%{{{ <head>

% this is for extracting the title
define extract_tag(tag)
{
   bob;
   !if (fsearch ("</" + tag)) return "";
   push_mark;
   ()=bsearch_char('>'); % will not work with nested tags
   go_right_1;
   bufsubstr_compress;
}

% Pages generated by Docbook are messy, but linuxdoc-generated pages are
% OK.  Todo: Docbook pages call the "contents" link "home".
static define parse_link(link)
{
   variable rel, href;
   if (string_match(link, "\\C<link.*href ?= ?\"\\([^\"]+\\)\".*REL ?= ?\"?\\([^\"]+\\)\"?", 1))
     string_nth_match(link, 1), strlow(string_nth_match(link, 2));
   else if (string_match(link, "\\C<link.*REL ?= ?\"\\([^\"]+\\)\".*href ?= ?\"?\\([^\"]+\\)\"?", 1))
     strlow(string_nth_match(link, 2)), string_nth_match(link, 1);
   else return;
   (href, rel) =(); 
   if (length(where(get_struct_field_names(links) == rel)))
     set_struct_field(links, rel, href);
}

static define get_links()
{
   bob;
   push_mark;
   ()=fsearch("<body");
   narrow;
   bob;
   while (fsearch("<link"))
     {
	push_mark;
	()=fsearch(">");
	parse_link(bufsubstr_compress());
     }
   widen;
   title = extract_tag("title");
   bob;
}


%}}}

%{{{ hrefs and anchors

static define markup_this_href()
{
   % get the link
   push_mark;
   ()=bsearch("<a");
   move_user_mark(this_href_mark);
   if (this_href_mark <= last_href_mark)
     return pop_mark_1; % ? skip this one
   move_user_mark(last_href_mark);
   exchange_point_and_mark;
   ()=dupmark;
   variable href = strcompress(bufsubstr(), " \n");
   variable target, text;
   % is it a href?
   if (string_match(href, "\\C<a [^<>]*href ?= ?\"\\([^\"]+\\)\"[^<>]*>\\(.*\\)", 1))
     {
	del_region;
	(target, text) = string_nth_match(href, 1), string_nth_match(href, 2);
	vinsert("<a href=\"%s\">\\link%d{%s}",
		target, % not really necessary since html2text will remove it
		href_i,
		text);
	href_list=strcat(href_list, strtrim(target), "\n");
	href_anchor_list=strcat(href_anchor_list, text, ",");
	href_i++;
     }
   % is it an anchor?
   else if (string_match(href, "\\C<a .*name ?= ?\"\\([^\"]+\\)\" ?>\\(.*\\)", 1))
     {
	del_region;
	target = string_nth_match(href, 1);
	vinsert("<a name=\"%s\">\\anchor%d|%s",
		target,
		anchor_i,
		string_nth_match(href, 2));
	anchor_list=strcat(anchor_list, target, "\n");
	anchor_i++;
     }
   else
     pop_mark_0;
}

static define mark_hrefs()
{
   variable message, progress;
   % display a progress indicator
   USER_BLOCK0
     {
	!if (progress mod 50)
	  {
	     flush (message);
	     message += ".";
	  }
	progress++;
     }
   
   bob;
   (anchor_list, href_list, href_anchor_list) = ("", "", "");
   href_begin_marks = Mark_Type[0];
   href_end_marks = Mark_Type[0];
   anchor_marks = Assoc_Type[Mark_Type];
   (href_i, anchor_i) = (0,0);
   this_href_mark = create_user_mark;
   last_href_mark = create_user_mark;
   set_struct_fields(links, NULL, NULL, NULL, NULL);
   get_links;
   % fix pages that look like
   % </a
   % >
   fix_broken_markup("</a");

   message = "parsing links"; progress = 0;

   %%% add some markup to links that will be left by html2text
   while (fsearch("</a>"))
     {
	X_USER_BLOCK0;
	markup_this_href;
	()=right(1);
     }
   href_list = strchop(href_list, '\n', 0);

   %%% convert to text
   flush("filtering");
   mark_buffer;
   %process_region(sprintf(Jedscape_Html_Filter, window_info('w') - 5));
   shell_cmd_on_region(sprintf(Jedscape_Html_Filter, window_info('w') - 5), 2);
   %%% process links
   href_begin_marks = Mark_Type[href_i];
   href_end_marks = Mark_Type[href_i];
   % html2text will break lines at "{", annoyingly it will also break
   % lines in tables, I can't handle links that run in columns.
   fix_broken_markup("\\\\link[0-9]+");
   variable i;
   message = "marking links"; progress = 0;
   while (re_fsearch("\\\\link[0-9]+{"))
     {
	X_USER_BLOCK0;
	deln(5);
	push_mark;
	skip_chars("0-9");
	i=integer(bufsubstr_delete);
	del; % {
	href_begin_marks[i] = create_user_mark;
	insert("[[:");
	()=fsearch_char('}');
	del;
	insert(":]]");
	href_end_marks[i] = create_user_mark;
     }
   clear_message;
   %%% process anchors
   bob;
   while (re_fsearch("\\\\anchor[0-9]+|"))
     {
	deln(7);
	push_mark;
	skip_chars("0-9");
	i=integer(bufsubstr_delete);
	del;
	anchor_marks[extract_element (anchor_list, i, '\n')] = create_user_mark;
     }
}

%}}}

%}}}

%{{{ browsing

static define goto_anchor(anchor)
{
   if (assoc_key_exists(anchor_marks, anchor))
     {
	goto_user_mark(anchor_marks[anchor]);
	recenter(3);
     }
}

define url_decode_string(string)
{
   string = " " + strtrans(string, "+", " ");
   while (string_match(string, "\\(.*\\)%\\([0-9][0-9A-F]\\)\\(.*\\)", 1))
     string = string_nth_match(string, 1) 
       + "\\" + char (integer("0x" + string_nth_match(string, 2)))
	 +string_nth_match(string, 3);
   return string;
}

define jedscape_mode();
define find_page();

% alpha support for running a program in /usr/lib/cgi-bin.  I can almost
% view info documentation with info2www and view manpages with man2html.
% Info and hyperman may be better suited, but man2html is faster than
% man.  The man2html index pages give me permission denied errors, but
% these would be too slow to markup anyway - to view the JED manpage just
% type "/cgi-bin/man2html?jed" at the open url prompt.
% 
% This uses a local variable url_file, the global one should not be
% trimmed of arguments because it will be pushed on the history when you
% move on.

define find_cgi_page(url_file)
{
   variable options = extract_element(url_file, 1, '?');
   if (options != NULL) 
     {
	options =  url_decode_string(options);
	% escape shell characters
	options = str_quote_string(options, "?*()&;\\", '\\');
     }
   else options ="";
   url_file = extract_element(url_file, 0, '?');
   % Some cgi-scripts send options as part of the filename
   while (1 != file_status(url_file))
     {
	options = "/" + path_basename(url_file) + options;
	url_file = path_dirname(url_file);
	if (strncmp(url_file, "/usr/lib/cgi-bin", 16))
	  verror ("can't find file %s", url_file);
     }
   sw2buf("*jedscape*");
   jedscape_mode;
   set_readonly(0);
   erase_buffer;
   ()=run_shell_cmd (url_file + " " + options);
   
   url_root=path_dirname(url_file);
   bob;
   % man2html does redirection
   if (looking_at("Location:"))
     {
	go_right(9);
	skip_white;
	push_mark_eol;
	find_page(bufsubstr);
     }
   else
     {
	mark_hrefs;
	set_buffer_modified_flag(0);
	set_readonly(1);
	bob;
	set_status_line(sprintf ("Jedscape: %s %%p", title), 0);
     }
}

define find_page(url)
{
   variable options = "", is_cgi=0;
   USER_BLOCK0
     {
	variable url_anchor = extract_element  (url, 1, '#');
	if (url_anchor != NULL)
	  goto_anchor(url_anchor);
     }

   % texi2html generated pages superfluously add the filename to #links
   url_file;
   url_file = extract_element  (url, 0, '#');
   if (andelse
       {url_file == ()}
       {bufferp("*jedscape*")}) return sw2buf("*jedscape*"), X_USER_BLOCK0;
   
   % if a pathname starts with "/cgi-bin" try to execute it.  A relative
   % url from a file in /usr/lib/cgi-bin will already have that as a path
   !if (strncmp(url_file, "/cgi-bin", 8))
     {
	url_file = "/usr/lib/cgi-bin/" + url_file[[8:]];
     }

   !if (strncmp(url_file, "/usr/lib/cgi-bin", 16))
     find_cgi_page(url_file);
   else
     {
	switch(file_status(url_file))
	  { case 1: }
	  { case 2: return dired_read_dir(url_file); }
	  { verror ("can't find file %s", url_file); }
	
	sw2buf("*jedscape*");
	jedscape_mode;
	set_readonly(0);
	erase_buffer;
	()=insert_file(url_file);
	url_root=path_dirname(url_file);
	mark_hrefs;
	set_buffer_modified_flag(0);
	set_readonly(1);
	bob;
	set_status_line(sprintf ("Jedscape: %s %%p", title), 0);
     }
   X_USER_BLOCK0;
}

%{{{ history stack

!if (is_defined ("jedscape_position_type"))
{
   typedef struct
     {
	filename,
	  line_number
     }
   jedscape_position_type;
}

variable jedscape_history = jedscape_position_type[16],
  jedscape_history_rotator = [[1:15],0],
  jedscape_stack_depth = -1,
  forward_stack_depth = 0;

define push_position(file, line)
{
   if (jedscape_stack_depth == 16)
     {
        --jedscape_stack_depth;
	jedscape_history  = jedscape_history [jedscape_history_rotator];
     }

   set_struct_fields (jedscape_history [jedscape_stack_depth], file, line);

   ++jedscape_stack_depth;
   forward_stack_depth = 0;
}

define goto_stack_position()
{
   variable pos, file, n;
   pos = jedscape_history [jedscape_stack_depth];
   file = pos.filename;
   n = pos.line_number;
   if (file != url_file)
     find_page(file);
   goto_line(n);
}

define goto_last_position ()
{
   if (jedscape_stack_depth < 0) return message("Can't go back");
   !if (forward_stack_depth)
     {
	push_position(url_file, what_line);
	--jedscape_stack_depth;
     }

   --jedscape_stack_depth;
   ++forward_stack_depth;
   goto_stack_position;
}

define goto_next_position()
{
   !if (forward_stack_depth) return message("Can't go forward");
   ++jedscape_stack_depth;
   --forward_stack_depth;
   goto_stack_position;
}


		 
%}}}

public define jedscape_get_url() % url
{
   !if (_NARGS) read_with_completion("open", "", "", 'f');
   variable last_file, last_line;
   (last_file, last_line) = (url_file, what_line());
   find_page();
   push_position(last_file, last_line);
}

%{{{ view history

define get_url_this_line()
{
   variable url = line_as_string;
   close_buffer;
   jedscape_get_url(url);
}

define view_history()
{
   popup_buffer("*jedscape history*");
   erase_buffer;
   variable i = 0, file = "";
   loop(jedscape_stack_depth + forward_stack_depth)
     {
	file;
	file = jedscape_history[i].filename;
	i++;
	if (file == ()) continue;
	insert (file + "\n");
     }
   fit_window;
   view_mode;
   set_buffer_hook("newline_indent_hook", &get_url_this_line);
}

define quit()
{
   push_position(url_file, what_line());
   url_file="";
   delbuf("*jedscape*");
}

%}}}

%{{{ follow hyperlink

define get_href()
{
   variable place, hrefs, href;
   place = create_user_mark;
   href = href_list[where(href_begin_marks <= place and href_end_marks >= place)];
   if (length(href))
     return href[0];
   else
     return "";
}

define follow_href() % href
{
   !if (_NARGS) get_href;
   variable href = ();
   !if (strlen(href)) return;
   if (is_substr(href, ":"))
     {
	variable url_type = extract_element(href, 0, ':');
	switch (url_type)
	  { case "mailto":
	     mail();
	     eol;
	     insert(extract_element(href, 1, ':'));
	  }
	  { case "http":
	     !if (strncmp ("http:/cgi-bin/", href, 14))
	       {
		  href=href[[5:]];
		  jedscape_get_url(href);
	       }
	     else
	       browse_url(href);
	  }
	  { case "file":
	     href = extract_element(href, 1, ':');
	     !if (strncmp (href, "//localhost", 11))
	       href = href[[11:]];
	     jedscape_get_url(href);
	  }
	  { vmessage ("%s urls are not supported yet", url_type);
	  }
	return;
     }
   if (href[0] == '#')
     {
	push_position(url_file, what_line);
	goto_anchor(href[[1:]]);
     }
   else if (href[0] == '?') % link to self in cgi file
     {
	if (strncmp(url_file, "/usr/lib/cgi-bin", 16))
	  error ("not in cgi directory");
	jedscape_get_url(extract_element(url_file, 0, '?') + href);
     }
   else
     jedscape_get_url(expand_filename(path_concat(url_root,href)));
}

%}}}

%{{{ info-like navigation

% dir
public define jedscape()
{
   find_page(Jedscape_Home);
}

% next, previous, up, top = "contents"
define follow_link(link)
{
   variable url = get_struct_field(links, link);
   if (url == NULL)
     {
	% Many docs have no links, but ordinary hrefs called "next"
	variable n = is_list_element(strlow(href_anchor_list), link, ',');
	if (n)
	  url = href_list[n-1];
	else
	  verror ("page has no %s", link);
     }
   jedscape_get_url(path_concat(url_root,url));
}

% menu
define complete_link()
{
   variable url = read_string_with_completion("Link", "", href_anchor_list);
   variable n = is_list_element(href_anchor_list, url, ',');
   if (n)
   {
      follow_href(href_list[n - 1]);
   }
}

%}}}

%}}}

%{{{ other interactive functions

define reread()
{
   what_line();
   url_file;
   url_file="";
   find_page();
   goto_line();
}

define view_source()
{
   ()=find_file(url_file);
}

define next_reference()
{
   go_right (fsearch("[[:"));
}

define previous_reference()
{
   if (bsearch(":]]"))
     {
	go_right(bsearch("[[:"));
     }
}

define view_help()
{
   variable file = (expand_jedlib_file("jedscape.html"));
   if (file == "") error ("can't find jedscape.html");
   jedscape_get_url(file);
}

%}}}

%{{{ mode stuff

%{{{ mouse

static variable mouse_href=-1;
static define mouse_hook(line, col, button, shift)
{
   switch(button)
     { case 1:  
	variable place, this_href;
	place = create_user_mark;
	this_href = 
	  where(href_begin_marks <= place and href_end_marks >= place);
	if (length(this_href)) 
	  {
	     this_href = this_href[0];
	     if (mouse_href == this_href)
	       follow_href(href_list[this_href]);
	     else
	       {
		  message(href_list[this_href]);
		  mouse_href=this_href;
	       }
	  }
	else mouse_href=-1;
     }
     { case 2: follow_href;}
     { goto_last_position;}
   -1;
}

static define mouse_2click_hook(line, col, button, shift)
{
   follow_href;
   1;
}

%}}}

create_syntax_table ("jedscape");
define_syntax('*', '#', "jedscape");
define_syntax("[[:", ":]]", '%', "jedscape");
set_syntax_flags("jedscape", 0x20);

%{{{ keymap


!if (keymap_p(mode))
  copy_keymap(mode, "view");
$1 = _stkdepth;
switch (Jedscape_Emulation)
{ case "lynx":
   "jedscape->next_reference",		Key_Down;
   "jedscape->previous_reference",	Key_Up;
   "jedscape->follow_href",		Key_Right;
   "jedscape->goto_last_position",	Key_Left;
   "jedscape->view_source",		"\\";
   "jedscape->view_history",		"";
   "write_buffer",			"p";
}
{ case "netscape":
   "scroll_down_in_place",	Key_Up;
   "scroll_up_in_place",	Key_Down;
   "jedscape->view_source",		"u";
   "jedscape->goto_last_position",	Key_Alt_Left;
   "jedscape->goto_next_position",	Key_Alt_Right;
}
{ case "w3":
   "jedscape->goto_last_position",	"B";
   "jedscape->goto_next_position",	"F";
   "jedscape->previous_reference",	"b";
   "jedscape->next_reference",		"f";
   "jedscape_get_url",			"o";
   "jedscape->view_source",		"s";
   "message(jedscape->get_href)",	"v";
   "jedscape->view_history",		"";
}
"jedscape_add_bookmark",	"a";
"jedscape_view_bookmarks",	"v";
"jedscape_index_search",	"i";
"jedscape",			"d";
"jedscape_get_url",		"g";
"jedscape->follow_href",	"^M";
"jedscape->goto_last_position",	"l";
"jedscape->goto_next_position",	";";
"jedscape->next_reference",	"\t";
"jedscape->follow_link(\"previous\")",	"p";
"jedscape->follow_link(\"next\")",	"n";
"jedscape->follow_link(\"up\")",	"u";
"jedscape->follow_link(\"contents\")",	"t";
"jedscape->complete_link",		"m";
"jedscape->view_history",		"h";
"jedscape->reread",			"";
"jedscape->quit",			"q";
loop ((_stkdepth - $1)/2)
  definekey(mode);

%}}}

define jedscape_bookmark_popup(menu)
{
   variable bookmark, bookmarks = strchop(strread_file(Jedscape_Bookmark_File), '\n', 0);
   foreach(bookmarks)
     {
	bookmark = ();
	bookmark = strchop(bookmark, '\t', 0);
	if (length(bookmark)<2) break;
	menu_append_item(menu, bookmark[0], sprintf("jedscape_get_url(\"%s\")",bookmark[1]));
     }

}

define jedscape_menu(menu)
{
   $1= _stkdepth;
   "&Report Bug",	". mail bob eol push_mark \"Cnhy <cnhy\d64obrxubbyg.pbwz>\" \"bw\" strcompress insert rot13";
   "&Source",		"jedscape->view_source";
   "&History",		"jedscape->view_history";
   "&Add Bookmark",	"jedscape_add_bookmark";
   "about",		"jedscape->view_help";
   "&Go to page",	"jedscape_get_url";
   "&Dir",		"jedscape";
   loop ((_stkdepth - $1)/2)
     menu_append_item(menu, _stk_roll(3));

   menu_append_popup(menu, "&Bookmarks");
   menu_set_select_popup_callback(menu+".&Bookmarks", &jedscape_bookmark_popup);
}

define jedscape_mode()
{
   use_syntax_table("jedscape");
   use_keymap(mode);
   set_mode(mode, 0);
   set_buffer_hook("mouse_up", &mouse_hook);
   set_buffer_hook("mouse_2click", &mouse_2click_hook);
   setbuf_info(getbuf_info, pop, 0x000);
   mode_set_mode_info(mode, "init_mode_menu", &jedscape_menu);
   run_mode_hooks("jedscape_mode_hook");
}

$1 = expand_jedlib_file("jedscape_hook.sl");
if ($1 != "")
  () = evalfile ($1);

%}}}
provide(mode);
